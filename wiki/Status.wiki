#summary The status of the project, including weekly status reports.

= Week 1,2 =
  * read lots of qemu src and LLVM API docs
  * compiled op.c to LLVM IR
  * wrote simple prototype which:
    * loads op.bc
    * resolves declarations in op.bc
    * creates a TB function
    * adds calls to micro ops
    * fills in parameters
    * inlines function calls
    * compiles the TB function to machine code with the JIT
  * started work on llvm-dyngen which at the moment:
    * handles micro ops with parameters

= Week 3 =
  * integrated llvm-dyngen into qemu:
    * changes to the qemu Makefiles
    * set up proper linking between C++ (llvm-dyngen, llvm libs) and C (qemu) parts
    * changes to functions which rely on the compiled micro op size (this is no longer possible with LLVM IR micro ops)
  * improved llvm-dyngen:
    * added support for the GOTO_LABEL_PARAM macro (this is used for jumps between individual micro ops of a translation block, e.g. it is used to implement the conditional execution emulation for the ARM architecture), this required changes to all micro ops which use GOTO_LABEL_PARAM
    * fixed missing parameters of memory access micro ops
    * added code generation through LLVM JIT
    * added code which properly registers global symbols with the JIT
    * added inlining of micro ops (doubles execution speed)
  * results:
    * llvm-qemu is capable of running ARM linux binaries in user mode emulation

= Week 4 =
  * did a lot of benchmarking and profiling with llvm-qemu (some of the logs are available in the profiling directory of the repository)
    * nbench (synthetic benchmark):
      * regular qemu:                                                   2.32 integer index
      * regular qemu without TB chaining:                               0.92 integer index
      * llvm-qemu with full optimizations (no TB chaining implemented): 0.75 integer index
      * llvm-qemu without optimizations   (no TB chaining implemented): 0.55 integer index
    * linux boot
      * regular qemu: 0:15 min
      * llvm-qemu:    1:15 min
  * got full system simulation working with llvm-qemu
  * implemented profiling facilities to see the number of executions of blocks and their size
  * implemented very simple hotspot-like mechanism which only applies optimizations to blocks which are executed a certain number of times, the other blocks are JITed directly without doing any further optimizations

= Week 5 =
  * implemented interpreter for qemu micro ops (to use as a "fast" pass for blocks with few executions, e.g. blocks which aren't hot spots)
    * created the interpreter version of dyngen:
      * inserts direct calls to micro ops instead of a memcpy of the micro op
      * parameters are kept in global variables and are fetched from the parameter array
      * micro ops which change control flow return a value which indicates the destination of the jump, the appropriate code which performs the jump is added
  * integrated interpreter into llvm-qemu, using it for blocks whose execution count is below a certain threshold
  * added code which prints a table of the execution count distribution of the executed blocks
  * results:
     * linux boot with llvm-qemu: 0:25 min

= Week 6 =
TODO list:
  * add support for translation block chaining to llvm-qemu
  * try to speed up the JIT process, e.g. by choosing a different register allocator
  * (low priority: fix full system emulation (linux boot hangs when entering user space))

